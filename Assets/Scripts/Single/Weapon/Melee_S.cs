using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class Melee_S : Weapon
{
    PlayerMove_S _playerMove;
    PlayerInputs _playerInputs;
    WeaponManager _weaponManager;

    BoxCollider _meleeArea;       // 근접 공격 범위
    TrailRenderer _trailEffet;    // 휘두를 때 효과
    Animator _animator;

    [Header("공격 관련")]
    bool _isSwingReady;  // 공격 준비
    float _swingDelay;   // 공격 딜레이
    bool _isStabReady;  // 공격 준비
    float _stabDelay;   // 공격 딜레이

    #region 절단 효과 변수
    public LayerMask _sliceMask; // 자를 대상인 레이어 마스크
    public float _cutForce = 250f; // 자를 때 가해지는 힘

    Vector3 _entryPoint; // 오브젝트에 들어간 지점
    Vector3 _exitPoint; // 오브젝트를 뚫고 나간 지점
    bool _hasExited = false; // 오브젝트를 뚫고 나갔는지 여부를 저장하는 변수
    #endregion

    private void Awake()
    {
        InitWeapon();
    }

    void InitWeapon()
    {
        base.Type = Define.Type.Melee;

        _meleeArea = gameObject.GetComponent<BoxCollider>();
        _trailEffet = gameObject.GetComponentInChildren<TrailRenderer>();

        // 무기 스탯 초기화
        WeaponData weapon = GameManager_S._instance.GetWeaponStatusByName(transform.name);
        if (weapon != null)
        {
            Debug.Log($"Weapon Name: {weapon.Name}. Attack: {weapon.Attack}, Rate: {weapon.Rate}");
            Attack = weapon.Attack;
            Rate = weapon.Rate;
            Range = weapon.Range;
        }
        else
        {
            Debug.LogWarning("Weapon not found!");
        }
    }


    void Start()
    {
        _playerMove = transform.root.GetChild(2).GetComponent<PlayerMove_S>();
        _playerInputs = transform.root.GetChild(2).GetComponent<PlayerInputs>();

        if (transform.root.childCount > 2)
        {
            _animator = transform.root.GetChild(2).GetChild(0).GetComponent<Animator>();
        }

        _meleeArea = gameObject.GetComponent<BoxCollider>();
        _trailEffet = gameObject.GetComponentInChildren<TrailRenderer>();

        // TODO
        /*
         * 무기 능력치를 엑셀이나 json을 이용해 관리 예정
         * 따로 읽어와서 그 값들을 세팅해줘야 함
         * 현재 임시로 테스트를 위해 하드코딩 함
        */

        //weaponData = JsonUtility.FromJson<WeaponData>(jsonData);
        // if (gameObject.tag == "Melee")
        //     base.Attack = 50;

    }

    void Update()
    {
        _swingDelay += Time.deltaTime;
        _stabDelay += Time.deltaTime;
    }

    /// <summary>
    /// 근접 공격: 좌클릭(휘두르기), 우클릭(찌르기)
    /// 공격 효과 코루틴 같이 실행된다.
    /// </summary>
    public override void Use()
    {
        _swingDelay += Time.deltaTime;
        _stabDelay += Time.deltaTime;
        _isSwingReady = base.Rate < _swingDelay; // 공격속도가 공격 딜레이보다 작으면 공격준비 완료
        _isStabReady = base.Rate < _stabDelay;
        int rayCount = 10;
        float angle = 60f;  // 부채꼴 각도
        float halfAngle = angle / 2.0f;
        Vector3 startPosition = transform.root.GetChild(2).position;
        startPosition.y += 1.0f;

        if (_playerInputs == null)
            _playerInputs = transform.root.GetChild(2).GetComponent<PlayerInputs>();
        if (_playerMove == null)
            _playerMove = transform.root.GetChild(2).GetComponent<PlayerMove_S>();

        if (_playerInputs.swing &&  _playerMove._grounded || _playerInputs.stab &&  _playerMove._grounded)
        {
            StopCoroutine("MeleeAttackEffect");

            //// 근접 무기가 아니거나 무기가 활성화 되어 있지 않으면 종료
            //if (_weaponManager._selectedWeapon.tag != "Melee" || !_weaponManager._selectedWeapon.activeSelf) return;

            // 공격속도가 공격 딜레이보다 작으면 공격준비 완료
            //_isSwingReady = _weaponManager._selectedWeapon.GetComponent<Melee>().Rate < _swingDelay;
            //_isStabReady = _weaponManager._selectedWeapon.GetComponent<Melee>().Rate < _stabDelay;

            if (_playerInputs.swing && _playerMove._grounded) // 휘두르기
            {
                Debug.Log("휘두르기");
                // _weaponManager._selectedWeapon.GetComponent<Melee>().Use();
                _animator.SetTrigger("setSwing");
                
                if(_isSwingReady == true && _isStabReady == true)
                {
                    _swingDelay = 0;
                    HashSet<Monster> hitMonsters = new HashSet<Monster>();
                    for (int i = 0; i < rayCount; i++)
                    {
                        float currentAngle = -halfAngle + (i * (angle / (rayCount - 1)));
                        Vector3 direction = Quaternion.Euler(0, currentAngle, 0) * transform.root.GetChild(2).forward;

                        RaycastHit hit;
                        if (Physics.Raycast(startPosition, direction, out hit, base.Range))
                        {
                            if (hit.collider.CompareTag("Monster"))
                            {
                                Monster monster = hit.collider.GetComponent<Monster>();
                                if (monster != null && !hitMonsters.Contains(monster))
                                {
                                    hitMonsters.Add(monster);
                                    StartCoroutine(DelayedDamage(monster));
                                }
                            }
                        }

                        Debug.DrawRay(transform.root.GetChild(2).position, direction * base.Range, Color.red, 1.0f);
                    }
                }
            }
            else if (_playerInputs.stab && _playerMove._grounded) // 찌르기
            {
                
                Debug.Log("찌르기");
                // _weaponManager._selectedWeapon.GetComponent<Melee>().Use();
                _animator.SetTrigger("setStab");
                _stabDelay = 0;

                if(_isSwingReady == true && _isStabReady == true)
                {
                    _stabDelay = 0;
                    HashSet<Monster> hitMonsters = new HashSet<Monster>();
                    for (int i = 0; i < rayCount; i++)
                    {
                        float currentAngle = -halfAngle + (i * (angle / (rayCount - 1)));
                        Vector3 direction = Quaternion.Euler(0, currentAngle / 2, 0) * transform.root.GetChild(2).forward;

                        RaycastHit hit;
                        if (Physics.Raycast(startPosition, direction, out hit, base.Range + 0.5f))
                        {
                            if (hit.collider.CompareTag("Monster"))
                            {
                                Monster monster = hit.collider.GetComponent<Monster>();
                                if (monster != null && !hitMonsters.Contains(monster))
                                {
                                    hitMonsters.Add(monster);
                                    StartCoroutine(DelayedDamage(monster));
                                }
                            }
                        }

                        Debug.DrawRay(transform.root.GetChild(2).position, direction * base.Range, Color.red, 1.0f);
                    }
                }

            }
            _playerInputs.swing = false;
            _playerInputs.stab = false;

            StartCoroutine("MeleeAttackEffect");
        }
        else
        {
            // 시작하자마자 휘두르는 문제 방지(유니티 Play 누를 때 클릭 때문에 그런 듯 하다)
            _playerInputs.swing = false;
            _playerInputs.stab = false;
        }
    }

    /// <summary>
    /// 코루틴으로 Collider, TrailRenderer 특정 시간 동안만 활성화
    /// </summary>
    IEnumerator MeleeAttackEffect()
    {
        yield return new WaitForSeconds(0.5f);
        _meleeArea.enabled = true;
        _trailEffet.enabled = true;

        yield return new WaitForSeconds(0.5f);
        _meleeArea.enabled = false;

        yield return new WaitForSeconds(0.5f);
        _trailEffet.enabled = false;
    }

    #region 절단 기능
    //칼이 트리거 안에 있을 때
    // _hasExited를 false로 설정
    // void OnTriggerEnter(Collider other)
    //  {
    //      _hasExited = false;
    //      _entryPoint = other.ClosestPoint(transform.position);

    //      // 데미지 적용

    //      // 자기 자신에게 닿은 경우 무시
    //      if (other.tag == "Player") return;

    //      if (other.GetComponent<Monster>() != null)
    //      {
    //          other.GetComponent<Monster>().TakedDamage(Attack);
    //      }
    //  }

    void OnTriggerStay(Collider other)
    {
        Debug.Log("관통");
    }

    // 관통 다 되면 레이어에 따라 절단
    void OnTriggerExit(Collider other)
    {
        // 충돌 지점의 방향을 자르는 방향으로 설정
        _exitPoint = other.ClosestPoint(transform.position);

        Vector3 cutDirection = _exitPoint - _entryPoint;
        Vector3 cutInPlane = (_entryPoint + _exitPoint) / 2;

        //Vector3 cutPlaneNormal = Vector3.Cross((entryPoint - exitPoint), (entryPoint - transform.position)).normalized;
        Vector3 cutPlaneNormal = Vector3.Cross((_entryPoint - _exitPoint), (_entryPoint - transform.position)).normalized;
        Debug.Log(cutPlaneNormal.x + ", " + cutPlaneNormal.y + ", " + cutPlaneNormal.z);

        if (cutPlaneNormal.x == 0 && cutPlaneNormal.y == 0 && cutPlaneNormal.z == 0)
        {
            // 원래 자르던 방향을 normalize 해서 넣어줘야 됨
            cutPlaneNormal = (_entryPoint - _exitPoint).normalized;
            Debug.Log("대체: " + cutPlaneNormal.x + " " + cutPlaneNormal.y + " " + cutPlaneNormal.z);

            bool isHorizontalCut = Mathf.Abs(cutDirection.x) > Mathf.Abs(cutDirection.y);

            // 가로로 자르는 경우
            if (isHorizontalCut)
            {
                // x 축 방향으로 자르기 때문에 cutPlaneNormal을 x 축 방향 벡터로 설정
                cutPlaneNormal = Vector3.up;
            }
            else // 세로로 자르는 경우
            {
                // y 축 방향으로 자르기 때문에 cutPlaneNormal을 y 축 방향 벡터로 설정
                cutPlaneNormal = Vector3.right;
            }
        }

        LayerMask cutableMask = LayerMask.GetMask(LayerMask.LayerToName(other.gameObject.layer));
        //Debug.Log("잘릴 레이어: " + LayerMask.LayerToName(other.gameObject.layer));
        if (_sliceMask.value == cutableMask)
        {
            Debug.LogWarning("자를 수 있는 오브젝트");
            // 오브젝트를 자르기
            Cutter.Cut(other.gameObject, cutInPlane, cutPlaneNormal);

            // 자를 때 가해지는 힘을 적용하여 오브젝트를 밀어냄
            Rigidbody rb = other.GetComponent<Rigidbody>();
            if (rb != null)
            {
                rb.AddForce(-cutPlaneNormal * _cutForce); // cutDirection 대신에 cutPlaneNormal을 사용
            }

            _hasExited = true;
        }
        else
        {
            //Debug.Log("sliceMask: " + sliceMask.value);
            //Debug.Log("자를 레이어: " + other.gameObject.layer);
            Debug.LogWarning("왜 안돼?");
        }
    }
    #endregion


    IEnumerator DelayedDamage(Monster monster)
    {
        yield return new WaitForSeconds(0.8f); // 0.5초 지연
        if(monster._isTakingDamage == false)
        {
            monster.TakedDamage(base.Attack);
            Debug.Log("적이 공격받았습니다: " + monster.name);
            monster.HitStart();
            monster._isTakingDamage = true;
        }
        yield return new WaitForSeconds(0.3f);
        monster._isTakingDamage = false;
    }
}